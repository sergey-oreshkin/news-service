# Кастомизация поиска 
## Продолжение
### Первая часть в ветке [main](https://github.com/sergey-oreshkin/news-service/tree/main)
### Вторая часть в ветке [jwt-auth](https://github.com/sergey-oreshkin/news-service/tree/jwt-auth)
### Третья часть в ветке [jwt-auth-adv](https://github.com/sergey-oreshkin/news-service/tree/jwt-auth-adv)

### Часть четвертая - кастомизация поиска

Выполнив это задание вы так же можете потестировать его работу открыв клиент [на этой странице](https://sergey-oreshkin.github.io/news-searcher-react/)


В этой части нужно добавить персонализацию rss источников и поиск по ним.  


Все новые эндпоинты должны быть доступны только авторизованным запросам.  
При ошибке авторизации(невалидном токене) - возвращать статус код **401**  
При неверных параметрах запроса - возвращать статус код **400** и json с полем **"error"** в котором можно передавать сообщение конечному пользователю. Это сообщение будет выведено в UI.
Rss источники будут передаваться в json формате с тремя полями:
- **title** - уникальное имя источника. У всех источников на сервере должны быть уникальные имена. Нельзя создать новый источник если имя уже занято, даже если занято другим пользователем.
- **link** - ссылка (URL). Естественно должна валидироваться на корректность написания и доступность. 
- **isActive** - булево значение указывающее включать ли в поиск результаты этого источника.   

Итак, добавьте следующие эндпоинты:   
1. **GET '/rss'** - доступен только авторизованным запросам.  
   **на входе** только проверка авторизации  
   **возвращает** список всех источников данного пользователя
2. **POST '/rss'** - - доступен только авторизованным запросам.   
   добавляет новый rss источник пользователю  
   **на вход** получает json с полями **title** и **link**  
   **возвращает** статус код 200 в случае успеха.
3. **PATCH '/rss'** - - доступен только авторизованным запросам.   
    запрос на изменение статуса isActive  
   **на вход** получает json с полями **title**, **link** и **isActive**  
   **возвращает** статус код 200 в случае успеха.
4. **DELETE '/rss/{title}'** - - доступен только авторизованным запросам.  
    запрос на удаление источника у данного пользователя  
   **на вход** получает уникальное имя источника в переменной пути  
   **возвращает** статус код 200 в случае успеха.  

Также необходимо поменять логику эндпоинта **POST '/'**. Теперь при запросе на него нужно определить 
кто именно к нему обращается и возвращать результаты поиска в соответствии с настройками для данного
пользователя. В случае если запрос не авторизован - возвращать поиск по дефолтным источникам.

Ну и конечно пора перенести хранение источников из файла в базу данных. При этом можно оставить файл, 
но использовать его только если база данных пуста для ее заполнения(то есть сценарий первого запуска на сервере).

Не стоит забывать и о кэшированиии, чтобы клиенты как можно быстрее получали свои новости. 
Кэширование можно пока оставить in memory, но, при желании, можно использовать и более продвинутые технологии.

#### Несколько подсказок
В спринге, при включенном секьюрити, для CORS запросов доступны не все HTTP методы.   
Один из способов это сконфигурировать это создать экземпляр класса `CorsConfiguration`.   
Засетить ему настройки. Примерно так  
`corsConfiguration.setAllowedOrigins(List.of("*"));
corsConfiguration.setAllowedHeaders(List.of("Authorization", "Cache-Control", "Content-Type"));
corsConfiguration.setAllowedMethods(List.of("GET", "POST", "PUT", "PATCH", "DELETE", "OPTIONS"));`   
Метод **OPTIONS** используется для обмена служебной информацией с браузером например, поэтому лучше его тоже включить.   
И передать этот объект конфигурации в наш HttpSecurity  
`http.cors().configurationSource(request -> corsConfiguration)`  
(это в классе `SecurityConfiguration` в методе `configure` из второй части)  
там же где мы применяем все остальные настройки.

Еще один момент связан с тем, что при неудачной авторизации запрос просто не доходит до контроллеров, 
а значит обрабатывать это исключение и формировать ответ нужно там, где мы уже знаем что авторизация не удалась - в нашем фильтре.(JwtFilter)   
Там нам доступен объект response - он приходит параметром метода, и именно его можно использовать для 
формирования ответа.   

Продолжение следует.. 
