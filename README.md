# Пример jwt авторизации для REST сервера 
## Продолжение
### Первая часть в ветке [main](https://github.com/sergey-oreshkin/news-service/tree/main)
### Третья часть в ветке [jwt-auth-adv](https://github.com/sergey-oreshkin/news-service/tree/jwt-auth-adv)
### Часть вторая - авторизация с помощью jwt токена

Для того, чтобы каждый мог настроить параметры поиска под себя, нам нужно как то отличать юзеров
и сохранять песональные настройки на сервере.   
В этой части мы сделаем авторизацию юзеров с помощью JWT токена 

Чтобы потестировать работу приложения можно перейти [на эту страницу](https://sergey-oreshkin.github.io/news-searcher-react/) и, при запущенном на вашей машине сервере, всё будет работать.   
В этой части нужно добавить следующие эндпоинты:
- **POST /register** принимает json{username, password}, записывает нового юзера в бд и выдает токен.
Возвращает код 200 и json с {username, token}. Если имя уже занято то код 400
- **POST /login** принимает json{username, password}, аутентифицирует юзера и выдает токен.
Возвращает код 200 и json с {username, token}. Если авторизация не успешна то отвечает кодом 401
- **GET /check** ничего не принимает. Возвращает код 200. Нужен для проверки токена со фронтенда

Ендпоинты **"/", "/register" и "/login"** должны быть доступны всем без авторизации.
Любые другие только авторизированным юзерам   
[Почитать про JWT токен](https://ru.wikipedia.org/wiki/JSON_Web_Token)   

### Работа с БД
В этом примере для работы с БД используется Hibernate. Вы можете тоже использовать его или любые другие
технологии для работы с БД   
Юзеры при регистрации должны сохранятся в БД вместе с зашифрованным паролем

### Что к чему в этом примере
Авторизация будет происходить на основании заголовка хттп запроса **"Authorization"**,
который должен содержать валидный токен
Любой запрос к спринговому серверу проходит цепочку фильтров прежде чем попасть в контроллер,
и мы встроим свой фильтр в эту цепочку, который будет записывать аутентификацию в секьюрити контекст спринга 

**Класс SecurityConfig**   
Вcе начинается с класса **SecurityConfig** наследника спрингового **WebSecurityConfigurerAdapter**. Пометим его @EnableWebSecurity чтобы спринг знал
что нужно включить секьюрити и сконфигурировать в соостветсвии с этим классом   
Так же нам понадобится пара бинов. Это какая-нибудь реализация PasswordEncoder и AuthenticationManager.
Попросим спринг поместить их в свой контекст аннотациями @Bean   
Дальше переопределим метод **configure** c параметром типа **HttpSecurity**   
В коде написано какие настройки применеяются, в том числе мы встраиваем наш **JwtFilter** в цепочку фильтров   

**Класс JwtFilter**   
Наследуется от спрингового **GenericFilterBean**   
В нем нужно переопределить метод **doFilter**. В этом методе мы получаем токен из заголовка **"Authorization"**,
проверяем,и ,если токен валиден, записываем авторизацию в SecurityContext. Наличие авторизации в SecurityContext
позволит этому запросу дойти до контроллеров. Кому интересно SecurityContext - thread local, то есть он существует
только в том потоке в котором создан и к нему нет доступа из других потоков. А значит при обращении к нему мы
получим именно того юзера который делал этот запрос.   
Тут же мы парсим из токена имя юзера и валидируем его с помощью **UserDetailsService**   

**Класс MyUserServiceDetails**   
Это наша реализация интерфейса **UserDetailsService**   
Тут мы реализуем метод **loadUserByUsername** который принимает имя пользователя.   
Проверяем есть ли в базе такой пользователь, и, если есть, возвращаем инстанс спрингового класса **User**, 
передавая туда имя и пароль. Именно с этим User **AuthenticationManager** будет сравнивать имя и пароль,
если его об этом попросят.

**AuthenticationManager**   
Мы попросили и спринг добавил нам его в контекст, так что теперь можно заинжектить его себе в контроллер
и проверять имя и пароль перед тем как выдать токен. 

Теперь при запросах на защищенные ендпоинты спринг будет их проверять с помощью нашего фильтра,
и пускать только тех кто прошел фильтр,
а в самих защищенных контроллерах мы можем узнать имя юзера взяв его из **SecurityContextHolder**

**JWT token**   
Формировать и парсить токен мы будем с помощью библиотеки **io.jsonwebtoken.jjwt**. 
Достаточно подключить ее в .pom файле.
Как формировать и парсить токен показано в коде.

#### Не забывайте зашифровать пароль перед сохранением в БД
Это можно сделать с помощью **PasswordEncoder** который мы поместили в контекст спринга.

...Продлжение следует


