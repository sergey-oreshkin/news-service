# Продвинутая jwt авторизация 
## Продолжение
### Первая часть в ветке [main](https://github.com/sergey-oreshkin/news-service/tree/main)
### Вторая часть в ветке [jwt-auth](https://github.com/sergey-oreshkin/news-service/tree/jwt-auth)
### Часть третья - продвинутая авторизация с помощью jwt токена

[Фронтенд к этому проекту](https://sergey-oreshkin.github.io/news-searcher-react/) 
уже следует приведенной ниже стратегии

Дело в том, что jwt токен - это токен на предъявителя. И если злоумышленнику удастся получить токен одного из клиентов,
он сможет действовать от его имени.   
Наша задача максимально усложнить жизнь злоумышленника. Для этого мы поступим следующим образом:
- При каждом вводе логина и пароля будем выдавать клиенту 2 токена, один обычный, но с коротким временем жизни
(например 1-3 минуты), а второй с длинным временем жизни(например 30 дней), но одноразовый. 
Назовем его рефреш токен.
- Создадим еще один эндпоинт **GET /refresh** который, в случае успешной авторизации по токену,
снова будет отдавать пару токенов - обычный и рефреш.
- На каждый ввод логина/пароля нужно создавать пулл рефреш токенов для этого юзера
и выдавать рефреш токены из этого пулла.
- Рефреш токен должен срабатывать только один раз, то есть если нам присылают на любой эндпоинт решреш токен
повторно, то сервер должен отвечать что клиент не авторизован, а также считать весь пулл рефреш 
токенов этого клиента скомпрометированным и больше не принимать токены из этого пулла.

#### Как это работает
Допустим злоумышленник каким-то образом украл обычный токен - тогда он сможет действовать лишь непродолжительное время
пока не истечет время жизни этого токена.
Допустим злоумышленник украл рефреш токен - тогда он сможет действовать до тех пор, пока настоящий юзер не запросит
обновление своего токена. В этом случае все его токены станут недействительными и получить новые он сможет только
если снова введет логин и пароль и будет создан новый пулл рефреш токенов для него.

Это конечно не решает всех проблем безопасности даже в части токенов, но этих мер вполне достаточно,
чтобы сильно ограничить возможности злоумышленника.

#### Итак к этому моменту должны быть следующие эндпоинты

1. **POST '/'** - доступен всем    
   **принимает** json формата `{"hours" : 12, "keywords" : ["keyword1",..,"keywordN"]}`   
   **возвращает** json формата `{"title" : "", "desc" : "", "link" : "", "date" : "2005-05-05" }`

2. **POST '/register'** - доступен всем  
   **принимает** json формата `{"username": "", "password" : ""}`   
   **возвращает** HTTP статус код 201 в случае успешной регистрации. Статус код 400 в случае если такое имя уже используется

3. **POST '/login'** - доступен всем  
   **принимает** json формата `{"username": "", "password" : ""}`   
   **возвращает** json формата `{"username: "", "token" : "", "refresh" : ""}` и статус код 200 в случае успешной авторизации   
   статус код 401 в случае не успешной

4. **GET '/check'** - доступен только авторизованным запросам  
   **принимает** токен в HTTP заголовке 'Authorization'  
   **возвращает** статус код 200 в случае валидного токена и статус код 401 в случае не валидного токена

5. **GET '/refresh'** - доступен только авторизованным запросам  
   **принимает** токен в HTTP заголовке 'Authorization'  
   **возвращает** json формата `{"username: "", "token" : "", "refresh" : ""}`, статус код 200 в случае валидного токена   
   и статус код 401 в случае не валидного токена   

В поле **token** соответственно должен передаваться обычный короткоживущий токен, 
а в поле **refresh** передаваться долгоживущий рефреш токен.

Все настройки, такие как время жизни токенов, секретное слово для их шифрования, креды для бд и т.п. должны быть вынесены либо 
в отдельный файл либо в переменные среды и браться оттуда.   

Продолжение в ветке [customization](https://github.com/sergey-oreshkin/news-service/tree/customization)
